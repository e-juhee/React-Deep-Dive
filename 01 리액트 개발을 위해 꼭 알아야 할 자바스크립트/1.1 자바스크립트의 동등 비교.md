# 1.1 자바스크립트의 동등 비교

> ### You will learn 😆
>
> - 1.1.1 자바스크립트의 데이터 타입
> - 1.1.2 값을 저장하는 방식의 차이
> - 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is
> - 1.1.4 리액트에서의 동등 비교

---

리액트의 가상 DOM과 실제 DOM의 비교,  
리액트 컴포넌트가 렌더링할지를 판단하는 방법,  
변수나 함수의 메모이제이션 등  
모든 작업은 자바스크립트의 **동등 비교**를 기반으로 한다.

자바스크립트의 동등 비교가 어떻게 수행되는지, 이를 리액트에서 어떻게 활용하고 있는지 알아보자!

# 1.1.1 자바스크립트의 데이터 타입

## 1) 원시 타입

- 객체가 아닌 다른 모든 타입
- 객체가 아니므로 메서드를 갖지 않는다.

### undefined

- 선언됐지만 할당되지 않은 값

### null

- 명시적으로 비어 있음을 나타내는 값
- 다른 원시값과 다르게 `typeof`로 null을 확인하면 `object`가 반환된다.

### Boolean

- boolean 형의 값 외에도 조건문에서 true, false처럼 취급되는 truthy, falsy 값이 있다.
  > #### falsy 값
  >
  > - 0, -0, 0n, 0x0n: 0은 부호나 소수점 유무에 상관없이 falsy
  > - NaN
  > - 공백이 없는 빈 문자열
  > - 당연한 것들: false, null, undefined
  >
  > #### truthy 값
  >
  > - falsy로 취급되는 값 이외에는 모두 truthy
  > - [], {}도 truthy

### Number

- 정수 실수 구분 없이 Number
- -(2^53-1) ~ 2^53-1
- 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않아 각 진수별로 값을 표현해도 모두 10진수로 해석되어 동일한 값으로 표시된다.

```js
0x10 == 16; // true
```

### BigInt

- Number보다 더 큰 수 저장 가능

```js
const bigInt1 = 9007199254740995n; // 끝에 n을 붙이거나
const bigInt2 = BigInt(9007199254740995); // BigInt로 감싼다

const number = 9007199254740995;
number == bigInt1; // true
number === bigInt1; // false -> 타입이 달라서
```

### String

- 원시 타입이므로 변경이 불가능하다.

### Symbol

- 중복되지 않는 어떠한 고유한 값
- Symbol 함수를 이용해서만 만들 수 있다.

```js
// Symbol : 항상 새로운 유니크한 심볼을 생성한다.
const key = Symbol("key");
const key2 = Symbol("key");

// Symbol.for : 해당 이름의 심볼이 존재한다면 그 심볼을 반환하고, 없으면 새로 생성한다.
Symbol.for("hello") === Symbol.for("hello"); // true
```

## 2) 객체 타입

- 7가지 원시 타입 이외의 모든 것
- 배열, 함수, 정규식, 클래스 포함
- 참조를 전달한다고 해서 참조 타임(reference type)으로도 불린다.

<br/>

# 1.1.2 값을 저장하는 방식의 차이

## 1) 원시 타입

- 원시 타입은 불변 형태의 값으로 저장된다.
  - 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.

## 2) 객체 타입

- 반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

<br/>

# 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

## 1) == VS Object.is

- == 비교는 타입이 다르면 type casting(강제 형변환)을 한 후에 비교한다.
- Object.is는 타입이 다르면 그냥 false

## 2) === VS Object.is

- 이 둘도 차이가 있다.
- Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교해줌!

```js
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

- 그렇지만.. Object.is를 써도 객체 비교는 ===와 동일함

<br/>

# 1.1.4 리액트에서의 동등 비교

- 그럼 리액트에서는 뭐로 비교함?!
  - 리액트에서는 Object.is를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 만들어서 사용한다.
  - 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용된다.

## 1) shallowEqual

- Object.is로 먼저 비교를 수행하고, 객체 간 얕은 비교를 한 번 더 수행한다.
  - 객체 간 얕은 비교: 객체의 첫 번째 깊이에 존재하는 값만 비교하는 것
- 얕은 비교까지만 구현한 이유는?
  - 리액트에서 사용하는 JSX props는 객체이고, 여기에 있는 Props만 일차적으로 비교하면 되기 때문이다.
  - 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분할 것이다.
  - 그러므로 props에 또 다른 객체를 넘겨준다면 렌더링이 예상치 못하게 작동한다.!
    - ex) React.memo: props가 깊어지는 경우(한 객체 안에 또다른 객체가 있으면) React.memo는 컴포넌트에 실제로 변경된 값이 없음에도 불구하고 메모이제이션된 컴포넌트를 반환하지 못한다.
- 싹 다 비교하기 위해 재귀문을 넣었으면 어땠을까?
  - 객체 안에 객체가 몇 개까지 있을지 알 수 없으므로 성능에 악영향을 미칠 것

---

### Q1. props 객체 안에 또 다른 객체를 담아서 컴포넌트에 전달할 경우, 성능에 어떤 영향을 줄까요? (주희)

### Q2. 리액트 useEffect와 관련하여 Object.is를 통한 동등비교가 훅의 성능 최적화에 어떻게 기여하나요? (승훈)

### Q3. 다음과 같은 예제 코드의 결과와 이유를 설명 해주세요(도영)

```javascript
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = Object.assign({}, obj1);

console.log(`obj1===obj2 => ${obj1 === obj2}`);
console.log(`obj1.b===obj2.b => ${obj1.b === obj2.b}`);
```

- Object.assign은 얕은 복사로 새 객체를 복사한다.
- Object.assign 첫 번째 인자에다가 두 번째 인자의 프로퍼티를 복사해서 추가한다.
  - 즉, obj1과 obj2는 false
- 참조 타입인 경우에는 주소값을 복사하기 때문에 true

### Q4. 정답입니다 ! 를 출력하기 위해 ? 자리에 들어올 수 있는 값은 무엇일까요? (경민)

```javascript
const x = ?;

if (x !== x) {
    console.log("정답입니다 !")
}
```

- JS의 동등비교 ===를 사용하는 경우에는 NaN과 NaN 서로 다르다고 인지한다.
- Object.is를 하면 NaN과 NaN을 비교했을 때 true

### Q5. 자바스크립트의 Map과 Set 객체에서는 동등성 비교를 어떻게 처리할까요? (책에 안 나온 방법입니다! 검색해보세요 - 채림)

- Map과 Set의 자료구조도 동등비교가 필요한 순간이 있겠지?
  - Map: key가 유일해야 하니까
    - 해쉬테이블인가요? ㅇㅇ
  - Set: 중복된 값인지 확인할 때
    - 해쉬테이블인가요? ㅇㅇ
- 이때, **SameValueZero 알고리즘**을 사용한다.
  - 이 SameValueZero 알고리즘은 **NaN도 유일한 값으로 인지**하게 동작한다.
  - SameValue라는 알고리즘도 있는데, 이 둘의 차이는 SameValueZero는 **+0𝔽와 -0𝔽를 동등한 값으로 취급한다**는 점만 SameValue와 다르다.
- JavaScript의 4가지 동등 알고리즘
  - - IsLooselyEqual: ==
  - - IsStrictlyEqual: ===
  - - SameValue: Object.is()
  - - SameValueZero: 많은 내장 연산에 사용됨.
