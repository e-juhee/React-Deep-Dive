# 9.2. 깃허브 100% 활용하기

> ### You will learn 📝
>
>- 9.2 깃허브 100% 활용하기
>   - 9.2.1 깃허브 액션으로 CI 환경 구축하기
>   - 9.2.2 직접 작성하지 않고 유용한 액션과 깃허브 앱 가져다 쓰기
>   - 9.2.3 깃허브 Dependabot으로 보안 취약점 해결하기
>   - 9.2.4 정리

---

### Q1. CI가 무엇인가요? 현재 CI 환경을 구축하기 위해 가장 인기있는 방식은 무엇이고, 왜 인기있는지 설명해주세요. (채림)
- CI
  - 코드의 변경사항을 자주 통합하고 검증해서 정합성을 유지하는 프로세스
  - 정합성: 데이터 간의 일관성(서로 일치하는 상태)
  - 코드가 변경될 때마다 빌드 테스트 배포 등을 자동으로 실행하는 것
- 젠킨스
  - 다양한 플러그인을 제공해서 여러 기능을 사용할 수 있어서 많이 사용했음
- 깃허브 액션
  - 젠킨스의 대안으로, 더 간단한 세팅이 장점
  - 가장 인기 있는 저장소인 깃허브에서 특별한 조치 없이 바로 연동해서 쓸 수 있는 것도 장점

### Q2. 깃허브 액션의 개념 중 액션, 잡, 스텝에 대해 설명해주세요. (채림)
- 액션: 깃허브 액션이 실행되는 서버(러너)에서 실행되는 하나의 작업 단위
- 잡: 여러 스텝을 모은 것
- 스텝: 잡 내부에서 실행되는 하나하나의 작업 단위
- 이 세 개를 묶어서 말하자면,,
  - 스텝은 명령어 한 줄 한 줄. 스텝을 모아서 '빌드하는 작업' '테스트 하는 작업' 등이 잡. 잡을 묶어서 yaml 파일에 넣은 것이 액션.
    - 그래서, 잡은 여러 개가 병렬로 실행될 수 있지만, 스텝은 병렬로 실행될 수 없다.

### Q3. 다음과 같은 깃허브 액션이 어떤 작업을 수행하는지 설명해 주세요. (유진)
  - `actions/checkout@v3`
    - 깃허브 저장소를 체크아웃하는 작업으로, 저장소를 기반으로 할 때 필수로 사용하는 액션
    - 디폴트는 가장 최신의 커밋을 가져옴
    - 특정 브랜치나 커밋으로 체크아웃 하는 것도 가능
  - `actions/setup-node@v3`
    - node를 설치하는 액션
    - node를 사용하는 경우 필수적으로 사용함
    - node 버전을 지정하려면, with.node-version.16 이런식으로 추가로 작성하면 버전 지정 가능

### Q4. 깃허브 액션을 활용해서 할 수 있는 작업은 어떤 것들이 있나요? (주희)
- CI 빌드
- 깃허브 API를 직접 호출해서 PR에 댓글 달기
- 일정 시간마다 특정한 작업 수행하기
- 배포 서비스와 연동해 자동으로 배포하기
- 저장소 내부에 이미지가 추가될 때마다 이미지 최적화 하기

### Q5. 유의적 버전(semantic versioning)의 정의에 대해 설명해 주세요. (유진)
- 주: 기존 버전과 호환되지 않게 변경됨
- 부: 기존 버전과 호환되면서 새로운 기능이 추가됨
- 수: 기존 버전과 호환되면서 버그를 수정한 것
- semantic version: 버전을 관리하기 위한 체계적인 규칙
- major / minor / patch

### Q6. 다음 예시를 보고, 각각의 패키지 버전이 어떤 규칙을 따르는지 설명해 주세요. (유진)
```
  - react@16.0.0: 16.0.0만으로 고정
  - react@^16.0.0: 16.0.0부터 17 미만 버전 (major 버전만 고정)
  - react@~16.0.0: patch 버전만 변경 가능
```

### Q7. 패키지가 의존하고 있는 의존성 라이브러리의 버전을 강제로 올리는 방법에 대해 설명해 주세요. (유진)
- package.json에 overrides 필드를 추가하고 원하는 패키지의 버전을 지정한 후 npm install을 실행해서 의존성을 설치한다.

### Q8. 버전이 `0.7.6`과 같이 0으로 시작하는 실험 버전 라이브러리를 사용할 때 주의할 점은 무엇인가요? (주희)
- 부버전이 올라가더라도 메이저와 비슷한 변경이 있을 수 있다.
- 주 버전이 0인 것은 초기 개발을 위해 쓰이므로 아무 때나 마음대로 바뀔 수 있다. ex) 0.7.6이었다가 0.8.0으로 버전이 올라간 경우 기능 추가뿐만 아니라 스펙이 변경되었을 수도 있다.

### Q9. `dependencies` `devDependencies` `peerDependencies`의 차이 (주희)
- dependencies: 프로젝트를 실행하기 위해 반드시 필요한 것으로, npm install 패키지명 입력하면 기본으로 여기로 들어감
- devDependencies: 개발 환경에서만 필요한 것으로, 프로젝트 실행에는 필요하지 않은 것
- peerDependencies: 직접 라이브러리를 쓰지는 않지만, 호환성으로 인해 필요한 경우. 주로 서비스보다는 라이브러리와 패키지에서 자주 쓰이는 단위.

### Q10. dependencies와 devDependencies로 앱 실행에 필요한 패키지를 구분하는 것이 앱의 최종 결과물에도 영향을 미칠까요? (주희)
1. 번들러의 존재
- 어디에 설치한 것이든 node_modules에 동일하게 설치된다.
- 실제 서비스에 배포해야 하는 라이브러리인지 결정하는 것은 번들러의 역할이다.
- 그래서 최종 결과물에는 영향을 전혀 미치지 않는다.

2. 과거에는 의미가 있었음
- 실제 프로젝트를 실행할 때 `npm install --only=production`으로 실행에 필요한 패키지만 빠르게 설치하는 전략이 주효했다.
- 하지만 현재의 앱 개발에서는 ts를 쓸 경우, ts를 devDependencies에 설치하면 `npm install --only=production`으로 실행했을 때 tsc(typescript compiler)가 실행되지 못해 시작은 커녕 빌드조차 할 수 없다.
- 따라서 dependenceis와 devDependencies의 경계가 모호해지고 있으며, 일부 프로젝트를 보면 둘을 구분하지 않고 모두 dependencies에 몰아넣고 관리하는 경우도 있음..

3. 하지만 무의미한 것은 아니다.
- npm에 업로드할 패키지를 개발한다면 두 의존성의 구분이 중요해진다.
  - 최종 패키지 결과물에는 dependencies에 있는 패키지들만 포함되게 해야 하므로

### Q11. 시멘틱 버저닝에 대해 설명하세요 (채림)
- 중복생략

### Q12. 깃허브 Dependabot으로 감지한 의존성 이슈를 수정하는 두 가지 방법에 대해 설명해주세요(채림)
- 의존성 이슈를 해결한 버전으로 업데이트 한다. (자동으로 pr을 만들어주기도 함)
- overrides로 강제로 버전을 업데이트 한다.
- +) 직접적으로 영향이 없을 것으로 판단되는 패키지에 대해서는 시급성을 낮춰서 대응해도 됨ㅎㅎ
