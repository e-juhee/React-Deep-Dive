# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

> ### You will learn 📝
>- 2.5.1 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자
>- 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

---

메모이제이션 기법은 언제 사용하는 것이 좋을까?  
'메모제이션은 무조건 필요하다 VS 섣불리 해서는 안 된다'에 대한 각 진영의 주장을 살펴보고,  
현명하고 효율적으로 메모이제이션하는 법을 알아보자!

# 2.5.1 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자
- 가벼운 작업은 메모이제이션하는 것보다 매번 작업을 다시 수행해 결과를 반환하는 것이 더 빠를 수도 있다.

## 1) 메모이제이션 비용
- 메모이제이션도 비용이 든다.
  - 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
  - 이전에 결과물을 저장해 두었다가 다시 꺼내와야 함
  - 이 비용이 리렌더링 비용보다 저렴하다고 할 수 있을까? 👉 상황에 따라 다를 것
- 섣부른 최적화는 경계해야 한다.
  - 섣부른 최적화 = premature optimization = premature memoization
- 만약 이런 비교와 렌더링이 문제가 됐다면 진작에 리액트에서 모든 컴포넌트를 PureComponent로 만들거나 memo로 감싸두는 작업을 했을 것
- 그러지 않고 개발자에게 선택권으로 줬다는 것은 메모이제이션이 모든 문제를 해결할 silver bullet은 아니라는 것!

## 2) 의미상으로 보장되지 않는다
- 메모이제이션을 한다고 해서 값을 기억하는 것을 항상 보장할 수는 없다.
  - 가능한 한 오랫동안 캐시 결과를 저장하려 하겠지만, 메모리가 해제되는 등의 이유로 경우에 따라서 캐시가 무효화되는 경우도 있을 수 있다!!

## 정리
- 미리 개발자가 예측해서 메모이제이션하는, 이른바 섣부른 최적화는 옳지 못하다.
- 애플리케이션을 어느 정도 만든 이후에 (개발자 도구나 useEffect를 사용해서) 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에만 최적화하는 것이 옳다.


# 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자
## 1) 잘못된 최적화로 인해 역으로 지불해야 하는 비용
- 잘못된 컴포넌트에 이뤄진 최적화란?
  - 렌더링 비용이 저렴하거나
  - 별로 렌더링이 안 되는 컴포넌트에 memo를 썼을 때!
- 지불해야 하는 비용은 **props에 대한 얕은 비교**가 발생하면서 지불하는 비용이다.
- 🤔 렌더링 결과물도 저장해둬야 하지 않나요?
  - 어차피 리액트는 원래 이전 렌더링 결과 저장하고 있음! (리액트의 재조정 알고리즘을 위해)
  - 그래서 props에 대한 얕은 비교 비용만 지불하면 된다.
- 반면 memo를 하지 않았을 때 발생할 수 있는 비용은
  - 렌더링
  - 컴포넌트 내부의 복잡한 로직의 재실행
  - 위 두 가지 모두 자식 컴포넌트에서도 반복해서 일어남
  - 리액트가 이전 트리와 새로운 트리를 비교함
- memo를 하지 않았을 때의 잠재적 비용이 더 크다.

## 2) useMemo와 useCallback은 언제 유용하지?
- 리렌더링이 발생할 때 메모이제이션을 해두지 않으면 모든 객체가 재생성되어 참조가 달라진다.
- 이 참조에 대한 값을 어디서든 안 쓰면 상관 없지만!
- 이 값이 의존성 배열 쓰인다면... 내부의 값은 같지만 계속 호출되겠지
- 참조 투명성: 객체를 useMemo로 감싸두면 값이 변경되지 않는 한 같은 결과물을 가질 수 있어서 **사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음**을 줄 수 있다.

<br/>

# 2.5.3 결론
- 리액트를 배우는 과정에서는 실제로 성능에 어떤 영향을 미치는지 꼼꼼하게 살펴보며 메모이제이션을 적용하자
  - 크롬 메모리 프로파일러로 분석하면서 state나 props의 변화에 따라 크롬 내부에서 어떤 일이 일어나는지 확인할 수 있음
- 현업에서 쓰거나 시간적 여유가 없다면 의심스러운 곳에서는 다 적용해보자
  - props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다.
  - 조금이라도 로직이 들어간 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 크다.
  - 객체가 props로 넘어가거나 활용할 여지가 있다면 useCallback, useMemo를 활용해서 참조 투명성을 유지할 수 있다.

---

### Q1. useMemo와 useCallback을 사용해서 메모이제이션 하는 것이 권장되는 상황은 언제인가요? (주희)
- 컴포넌트 내부에 정의된 함수나 객체는 리렌더링이 발생할 때 모두 재생성되어 참조가 달라집니다.
- 이렇게 재생성되는 함수나 객체가 props로 전달되거나 의존성 배열에 들어간다면, 내부의 값이 같은데도 불필요하게 다시 계산하게 됩니다.
- 이런 경우에 useCallback, useMemo를 활용해서 참조 투명성을 유지하면 객체나 함수를 사용하는 곳에서도 변하지 않는 고정된 값을 사용할 수 있습니다.

### Q2. 다음 코드에서 예상되는 동작과 문제점을 설명하고 해결책을 제안해주세요. (경민)

```javascript
// useState와 useEffect는 import 했습니다.

function useInvest(number: number) {
    const [seedMoney, setSeedMoney] = useState(0);
    const [debt, setDebt] = useState(0);

    useEffect(() => {
        setSeedMoney(number - 1000);
        setDebt(number * 2);
    }, [number]);

    return { seedMoney, debt }
}

export default function App() {
    const [counter, setCounter] = useState(0);
    
    const yourAccount = useInvest(10000);

    useEffect(() => {
        console.log(yourAccount.seedMoney, yourAccount.debt);
    }, [yourAccount])

    function handleClick() {
        setCounter((prev) => prev + 1);
    }

    return (
        <>
            <h1>{counter}</h1>
            <button onClick={handleClick}>+</button>
        </>

    )
}
```
- yourAccount가 매변 새로운 참조를 가지게 되어 의도하지 않은 리렌더링이 발생할 수 있다.
- useMemo를 사용하거나 의존성 배열을 [yourAccount.seedMoney, yourAccount.debt]로 변경한다.

### Q3. useMemo로 모조리 캐싱하면 좋지 않을까요? 하지않는다면 이유가뭐고 언제 사용할까요?(민규)
- 메모이제이션을 하면 값을 비교하는 작업이 필요한데 이 또한 비용이므로 섣부른 최적화는 경계해야 한다.
- 가벼운 작업은 메모이제이션하는 것보다 매번 작업을 다시 수행해 결과를 반환하는 것이 더 빠를 수도 있다.
- 애플리케이션을 어느 정도 만든 이후에 (개발자 도구나 useEffect를 사용해서) 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에만 최적화하는 것이 옳다.

### Q4. `memo`, `useMemo` 둘의 차이점과 각각의 사용 목적에 대해서 설명해주세요.(도영)
- memo는 고차 컴포넌트로 컴포넌트의 렌더링을 메모이제이션한다.
  - 부모 컴포넌트가 재렌더링되어도 자식 컴포넌트의 props가 변하지 않았다면, 자식 컴포넌트의 렌더링을 생략한다.
- useMemo는 hook으로, 값을 메모이제이션해서 불필요한 재계산을 방지한다.
