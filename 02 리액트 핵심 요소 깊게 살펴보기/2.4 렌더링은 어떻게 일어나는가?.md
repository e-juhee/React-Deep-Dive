# 2.4 렌더링은 어떻게 일어나는가?

> ### You will learn 🌲
>- 2.4.1 리액트의 렌더링이란?
>- 2.4.2 리액트의 렌더링이 일어나는 이유
>- 2.4.3 리액트의 렌더링 프로세스
>- 2.4.4 렌더와 커밋
>- 2.4.5 일반적인 렌더링 시나리오 살펴보기

![image](https://github.com/Jungle-JavaScript-Study/react-deep-dive/assets/82787570/a48acba3-7530-419a-806b-587993a16a90)

---

### Q1. 리액트의 렌더링 과정이 동기식이 아닌 비동기식으로 작동한다면 어떤 장단점이 있을까요? (주희)
- 비동기
  - 응답이 오는 것을 기다리지 ㅇ낳고 렌더/커밋하므로 응답이 느려져서 렌더링 지연을 방지할 수 있다.
  - 스테이트값이 내가 원하는대로 반영되지 ㅇ낳을 수 있다.
- 단점) 사용자가 하나의 상태에 대해 여러 가지 다른 UI를 보게 되어 혼란을 줄 수 있다.
- 장점) 먼저 렌더링 되어야 하는 컴포넌트의 작업이 무겁다면 상대적으로 빠르게 렌더링할 수 있는 우선순위가 낮은 컴포넌트를 먼저 보여주어 최적화할 수 있다.
- 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 동시성 렌더링은 리액트 18에 도입되었다.
- 특정 렌더링의 우선순위를 낮추거나, 중단하거나 재시작하거나, 경우에 따라서는 포기할 수 있다.
- 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도 있으므로 사용자는 더욱 매끄러운 사용자 경험을 누릴 수 있다.

### Q2. A(부모) -> B -> C -> D(자식)로 이어지는 4중 중첩 구조의 컴포넌트가 있습니다. 
Context API를 사용하여 만든 LoadingProvider로 A 컴포넌트를 감싸 isLoading과 setIsLoading 값을 전달합니다. 
D 컴포넌트에서 setIsLoading을 호출하여 isLoading의 값을 변경했을 때, 어떻게 렌더링이 일어나게 될까요? (경민)
컨텍스트{A{B{C{D -> 여기서 setIsLoading 호출}}}}

- 1) isLoading 값이 변경된다.
- 2) 감싸져 있는 자식들이 모두 업데이트되고 렌더링된다.

### Q3. 리액트의 렌더링 과정에 대해서 설명해 주세요. (도영)
- 렌더링 프로세스가 시작되면 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
- 업데이트가 필요한 컴포넌트를 발견하면 '클래스 컴포넌트는 render() 함수를 실행' / '함수 컴포넌트는 FunctionComponent() 그 자체를 호출'하고 그 결과물을 저장한다.
- 일반적으로 렌더링 결과물은 JSX 문법으로 구성돼 있고, JS로 컴파일되면서 React.createElement()를 호출하는 구문으로 변환된다.
    - createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 JS 객체를 반환한다.
- 렌더링 프로세스가 실행되면서 이런 과정을 거쳐 컴포넌트의 렌더링 결과물을 수집하고,
- 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경사항을 수집해나간다.
    - 이렇게 계산하는 과정을 리액트의 재조정(Reconciliation)이라고 한다.
- Reconciliation이 끝나면 모든 변경사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

### Q4. 컴포넌트를 `memo`로 선언했음에도 **매번** 리렌더링 되는 경우 원인에 어떤 것이 있을까요? (채림)
- props에 객체나 배열처럼 매번 새로운 객체를 만들어서 전달하게 되면 매번 다른 주소값이 전달되므로 memoization이 의미가 없다.
- 컴포넌트의 key에 랜덤값을 전달하면 매번 리렌더된다.
  - 컴포넌트를 매번 새로 마운트하는 것이다. (즉, 리렌더가 아닌 렌더링)

### Q5. 아래 코드의 렌더링 시나리오를 설명해주세요. (승훈)
```js
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

```
(마더)  (파더)
 |       |
(자식)  (자식)
왼쪽 자식과 오런쪽 자식은 다른 아이임. 상태도 별도.
```

- useState 호출해서 count가 0으로 설정되어 화면을 그린다.
- 버튼을 누르면 setCount로 state가 변경되어 화면을 다시 그린다.
  - setState가 호출되어 새로운 가상DOM이 생성되고 이전 가상DOM과 비교해서 달라진 부분을 실제 DOM에 커밋한다.

렌더링이 일어남 -> 변경 사항 계산 -> 변경사항 있으면 커밋
